Final Project Plan

1. Business Story
In the dynamic construction industry, accurately and efficiently generating quotes (Configure, Price, Quote - CPQ) is a significant challenge. Traditional methods often involve complex spreadsheets, manual calculations, and product-specific logic, as seen in the legacy wood fence pricing example. This leads to inconsistencies, errors, increased time-to-quote, and difficulty in adapting to new products or pricing structures.

This project aims to develop a generic Construction CPQ system. The core idea is to move away from hardcoded, specific calculators towards a flexible, data-driven platform. Users will configure "Products" (e.g., "6ft Postmaster Horizontal JPC Stained Fence") composed of various "Materials" (e.g., JPC wood pickets, Postmaster posts, concrete). These products can have "Variations" (e.g., "Board-on-Board style," "Added Cap Rail") that modify materials, labor, or price.

The system will allow administrators to define materials with their costs and units, assemble these into base products, and define variation options through a user-friendly interface (NocoDB connected to a PostgreSQL database). Salespersons or estimators will then use a frontend application to select products for a job, choose applicable variations, and specify quantities. The backend will calculate a detailed quote, including a bill of materials, total material costs, labor costs, cost of goods sold (COGS), and apply configurable overheads (like sales commission, franchise fees) and margins. Finally, it will calculate taxes and present a final job price.

This generic CPQ system will empower construction businesses to:
- Standardize Quoting: Ensure consistency and accuracy across all quotes.
- Increase Efficiency: Drastically reduce the time taken to generate complex quotes.
- Improve Flexibility: Easily add new products, materials, or pricing rules without code changes.
- Enhance Transparency: Provide clear breakdowns of costs and pricing to customers and internal teams.
- Scale Operations: Support business growth by streamlining a critical sales process.

The ultimate goal is a robust, maintainable, and adaptable CPQ solution that can serve a wide range of construction product configurations, moving beyond the limitations of single-purpose calculators.

2. Requirements
1. Quoting System: Generate quotes based on selected products, applying margins, taxes, and fees.
2. Variations: Support product variations with options that can add materials, modify prices, and labor costs.
3. Generic as possible: The system should be flexible enough to accommodate various types of products and materials without hardcoding specific values.
4. Json Seeding: Use a JSON file to seed the database with initial data for products, variations, materials, and configurations.
5. Calculated Quotes: Provide a calculated quote model that summarizes the bill of materials, total costs, labor costs, and final price.
6. Frontend Quote App: Implement a frontend application that allows users to create quotes, add products, select variations, and view calculated quotes.
7. Abstraction of Units: Robust solution for handling different unit types (length, area, volume, count, etc.) for materials and products.

3. Questions
1. How will the system handle different unit types (length, area, volume) and conversions between them? Think on a situation product is fence that is measured by foot but the wood materials are measured by unit. general way to solve this issue in construction projects (for various size measurements, units, etc) the question is what will work.

Answer: The system will manage units by:
- Defining a unit_type table (e.g., 'meter', 'foot', 'kg', 'each', 'box', 'sheet'). Each unit type will have a category (e.g., 'length', 'mass', 'count', 'area', 'volume') to prevent illogical operations, though direct conversion between categories (e.g., length to mass) is not a primary goal for the CPQ calculation itself.
- Materials will be defined with a cost_per_supplier_unit (e.g., cost per 'box' of screws), the supplier_unit_type_id, the quantity_in_supplier_unit (e.g., 100 screws in a box), and a base_unit_type_id (e.g., 'each' screw). This allows the system to calculate a cost_per_base_unit for each material.
- Products will have a product_unit_type_id (e.g., 'linear foot' for a fence).
- The link between a product and its materials (product_material table) will specify the quantity_of_material_base_units_per_product_unit. For example, a "Fence" product (unit: 'linear foot') might require 2 'each' of "Picket X" (material base unit: 'each') per 'linear foot' of fence.
- This approach ensures that all material quantities are normalized to their base units, and then related to the product's primary unit of measure. The calculation logic will sum up costs based on these defined relationships, effectively handling the "fence by foot, wood by piece" scenario without needing complex dynamic unit conversion factors during quote calculation. The conversion is implicitly handled by how product_material quantities are defined.

2. How will the system manage product variations and their associated materials and labor costs? Should variations be tightly coupled with products or managed separately?

Answer: Product variations will be managed by coupling them with products, but with a flexible structure:
- A product can have multiple variation_groups (e.g., "Style", "Add-ons", "Height Options" if height is treated as a variation for a base product type).
- Each variation_group (e.g., "Style" for a specific fence product) will have multiple variation_options (e.g., "Side-by-Side", "Board-on-Board").
- Each variation_option can:
    - Specify additional_materials to be added (via variation_option_material table), including their quantities per product unit. This could also potentially modify quantities of base product materials if a variation replaces a component.
    - Have an additional_price (a fixed amount added to the product's price).
    - Have a price_multiplier (e.g., 1.1 for a 10% uplift on a portion of the cost or price).
    - Have an additional_labor_cost per product unit.
- This structure keeps the definition of what can vary specific to a product (tight coupling for relevance) but allows the impact of each variation option (materials, cost, labor) to be managed distinctly and additively or subtractively.
- The distinction between a new product and a variation will be a configuration choice:
    - New Product: Typically created when core components, primary material types (e.g., wood species like JPC vs. WRC), or fundamental dimensions (e.g., 6ft fence vs. 8ft fence, if this significantly changes base material lists) change.
    - Variation: Used for optional add-ons (e.g., cap, trim), stylistic choices (e.g., picket arrangement like SxS vs. BoB), or minor modifications that don't alter the fundamental bill of materials of the base product drastically but rather augment or slightly change it.

4. Initial Schema (PostgreSQL - snake_case)

-- Unit types for materials and products
CREATE TABLE unit_type (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL, -- e.g., 'kg', 'meter', 'each', 'linear_foot', 'square_meter', 'box'
    category VARCHAR(50) NOT NULL -- e.g., 'mass', 'length', 'count', 'area', 'volume'
);

-- Materials used in construction
CREATE TABLE material (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    cost_per_supplier_unit DECIMAL(10, 2) NOT NULL, -- Cost for one supplier unit (e.g., cost of a box)
    supplier_unit_type_id INT REFERENCES unit_type(id), -- Unit of purchase (e.g., 'box')
    quantity_in_supplier_unit DECIMAL(10, 3) NOT NULL DEFAULT 1.0, -- How many base units in one supplier unit (e.g., 100 screws per box)
    base_unit_type_id INT REFERENCES unit_type(id) NOT NULL -- Fundamental unit for calculation (e.g., 'each' screw)
    -- Calculated effective_cost_per_base_unit = cost_per_supplier_unit / quantity_in_supplier_unit
);

-- Products offered
CREATE TABLE product (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    description TEXT,
    product_unit_type_id INT REFERENCES unit_type(id) NOT NULL, -- Unit this product is measured/sold in (e.g., 'linear_foot')
    base_labor_cost_per_product_unit DECIMAL(10, 2) DEFAULT 0.00 -- Base labor cost for one unit of this product
);

-- Materials required for a base product (before variations)
CREATE TABLE product_material (
    id SERIAL PRIMARY KEY,
    product_id INT REFERENCES product(id) ON DELETE CASCADE NOT NULL,
    material_id INT REFERENCES material(id) ON DELETE RESTRICT NOT NULL,
    -- How many base units of the material are needed for one unit of the product
    quantity_of_material_base_units_per_product_unit DECIMAL(10, 3) NOT NULL,
    UNIQUE (product_id, material_id)
);

-- Groups of variations for a product (e.g., "Fence Style", "Add Cap")
CREATE TABLE variation_group (
    id SERIAL PRIMARY KEY,
    product_id INT REFERENCES product(id) ON DELETE CASCADE NOT NULL,
    name VARCHAR(100) NOT NULL, -- e.g., "Style", "Cap Option"
    selection_type VARCHAR(20) NOT NULL DEFAULT 'single_choice', -- 'single_choice', 'multi_choice'
    is_required BOOLEAN DEFAULT FALSE,
    UNIQUE (product_id, name)
);

-- Specific options within a variation group (e.g., "Board-on-Board", "With Cap")
CREATE TABLE variation_option (
    id SERIAL PRIMARY KEY,
    variation_group_id INT REFERENCES variation_group(id) ON DELETE CASCADE NOT NULL,
    name VARCHAR(100) NOT NULL, -- e.g., "Side-by-Side", "Yes - Add Cap"
    value_description TEXT, -- Further description of the option
    additional_price DECIMAL(10, 2) DEFAULT 0.00, -- Fixed price added
    price_multiplier DECIMAL(5, 3) DEFAULT 1.000, -- Multiplier (e.g., 1.1 for 10% increase)
    additional_labor_cost_per_product_unit DECIMAL(10, 2) DEFAULT 0.00, -- Added labor for this option
    UNIQUE (variation_group_id, name)
);

-- Materials added or modified by a specific variation option
CREATE TABLE variation_option_material (
    id SERIAL PRIMARY KEY,
    variation_option_id INT REFERENCES variation_option(id) ON DELETE CASCADE NOT NULL,
    material_id INT REFERENCES material(id) ON DELETE RESTRICT NOT NULL,
    -- How many base units of material are added per product unit for this option.
    -- Can be negative if this option replaces/reduces a base material.
    quantity_of_material_base_units_added DECIMAL(10, 3) NOT NULL,
    UNIQUE (variation_option_id, material_id)
);

-- Configuration for a quote (margins, taxes, fees)
CREATE TABLE quote_config (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE DEFAULT 'Default Quote Config',
    margin_rate DECIMAL(5, 4) DEFAULT 0.30, -- e.g., 0.30 for 30%
    tax_rate DECIMAL(5, 4) DEFAULT 0.00,    -- e.g., 0.085 for 8.5%
    sales_commission_rate DECIMAL(5, 4) DEFAULT 0.00,
    franchise_fee_rate DECIMAL(5, 4) DEFAULT 0.00,
    additional_fixed_fees DECIMAL(10, 2) DEFAULT 0.00
);

-- Represents a quote
CREATE TABLE quote (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    description TEXT,
    quote_config_id INT REFERENCES quote_config(id) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'draft', -- 'draft', 'calculated', 'sent', 'accepted', 'rejected'
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Products included in a quote
CREATE TABLE quote_product_entry (
    id SERIAL PRIMARY KEY,
    quote_id INT REFERENCES quote(id) ON DELETE CASCADE NOT NULL,
    product_id INT REFERENCES product(id) ON DELETE RESTRICT NOT NULL,
    quantity_of_product_units DECIMAL(10, 2) NOT NULL,
    notes TEXT
);

-- Selected variations for a product entry in a quote
CREATE TABLE quote_product_entry_variation (
    id SERIAL PRIMARY KEY,
    quote_product_entry_id INT REFERENCES quote_product_entry(id) ON DELETE CASCADE NOT NULL,
    variation_option_id INT REFERENCES variation_option(id) ON DELETE RESTRICT NOT NULL,
    UNIQUE (quote_product_entry_id, variation_option_id) -- Assuming one option per group, or handled by group type
);

-- Stores the result of a quote calculation
CREATE TABLE calculated_quote (
    id SERIAL PRIMARY KEY,
    quote_id INT REFERENCES quote(id) ON DELETE CASCADE NOT NULL UNIQUE,
    bill_of_materials_json JSONB, -- List[Dict[material_name, quantity, unit_cost, total_cost]]
    total_material_cost DECIMAL(12, 2) NOT NULL,
    total_labor_cost DECIMAL(12, 2) NOT NULL,
    cost_of_goods_sold DECIMAL(12, 2) NOT NULL, -- total_material_cost + total_labor_cost
    applied_rates_info_json JSONB, -- List[Dict[name, type, rate_value, applied_amount]] (for commission, franchise, margin, fees)
    subtotal_before_tax DECIMAL(12, 2) NOT NULL, -- COGS + all markups/fees from applied_rates_info_json
    tax_amount DECIMAL(12, 2) NOT NULL,
    final_price DECIMAL(12, 2) NOT NULL,
    calculated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- Trigger to update 'updated_at' on quote table
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_quote_timestamp
BEFORE UPDATE ON quote
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

5. Backend Structure

The backend will be a Python FastAPI application.

Description:
- main.py (or run.py): Entry point to start the Uvicorn server for the FastAPI application.
- app/api.py: Defines all API routes/endpoints (e.g., /quotes, /quotes/{id}/calculate, /products, /materials). Handles request validation and calls appropriate service functions.
- app/models.py: Contains SQLModel ORM models mirroring the PostgreSQL schema, and other necessary models for the application.
- app/services/quote_calculator.py: Core logic for calculating a quote. Takes a Quote ID, fetches its products, selected variations, materials, labor costs, and applies QuoteConfig rules (margins, fees, tax) to generate a CalculatedQuote.
- app/services/data_service.py: Service layer for CRUD operations on products, materials, variations if logic is more complex than direct ORM use in API routes.
- app/database.py: SQLModel engine setup, session management, and base for ORM models.
- app/config.py: Application configuration (database URL, secret keys, etc.), loaded from environment variables.
- seed.py (top-level or in app/db/): A script to populate the database with initial data from seed.json. Run manually or as part of deployment.
- seed.json (in a seed_data directory): JSON file containing initial data for unit_type, material, product, variation_group, variation_option, variation_option_material, quote_config.
- Dockerfile: To build the Docker image for the backend application.
- requirements.txt: Lists all Python dependencies (FastAPI, Uvicorn, SQLModel, Pydantic, Psycopg2-binary, etc.).

Full File Structure (backend/):
backend/
├── app/
│  ├── api.py
│  ├── models.py    
│  ├── services/
│  │   ├── quote_calculator.py
│  │   └── data_service.py
│  ├── database.py
│  ├── config.py
├── seed.py
├── seed.json
├── main.py
├── Dockerfile
├── requirements.txt
└── (tests/ directory would also be here)

6. Frontend Structure

The frontend will be a React (Next.js recommended for structure and SSR/SSG capabilities) application.

Description:
- The primary goal is to allow users to:
    1. Create a new quote or select an existing one.
    2. Add products to the quote.
    3. For each product, view and select available variations.
    4. Specify the quantity for each product entry.
    5. Trigger the quote calculation via a backend API call.
    6. View the detailed CalculatedQuote (BOM, costs, fees, final price).
- get_quote.tsx is a conceptual representation. A more structured approach would involve multiple pages and components.
- Key components/pages:
    - Quote list and creation page.
    - Quote detail page:
        - Component to add/edit products in the quote.
        - Component to select variations for each product.
        - Component to display the calculated quote summary and details.
- State management (Context API, Redux, Zustand, etc.) will be needed for managing quote data.
- API service module to interact with the backend.

File Structure (frontend/): (Example using Next.js app router)
frontend/
├── app/
│   ├── quotes/
│   │   ├── page.tsx                     // List existing quotes, create new
│   │   └── [quoteId]/
│   │       ├── page.tsx                 // View/Edit specific quote, trigger calculation
│   │       └── components/
│   │           ├── ProductSelector.tsx
│   │           ├── VariationSelector.tsx
│   │           ├── QuoteProductList.tsx
│   │           └── CalculatedQuoteView.tsx
│   ├── (auth/ if authentication is added)
│   ├── layout.tsx
│   └── globals.css
├── components/                          // Shared UI components
│   └── (e.g., Button.tsx, Modal.tsx)
├── services/
│   └── apiClient.ts                     // Functions to call backend APIs
├── contexts/                            // React Context for state management (optional)
│   └── QuoteContext.tsx
├── types/
│   └── index.ts                         // TypeScript interfaces for API data
├── public/                              // Static assets
├── Dockerfile
├── package.json
├── tsconfig.json
└── next.config.js

7. Repo Structure (Main File Structure and Docker Compose Overview)

Main File Structure:
cpq-system/
├── backend/                 # FastAPI application (as detailed above)
├── frontend/                # React/Next.js application (as detailed above)
├── .env                     # Environment variables for all services (DB creds, API keys, etc.)
├── .gitignore
├── docker-compose.yml
└── README.md

Docker Compose Overview (docker-compose.yml):
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    container_name: cpq_postgres_db
    restart: unless-stopped
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Optional: ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432" # Expose only if needed externally, backend connects via Docker network
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: cpq_backend_api
    restart: unless-stopped
    ports:
      - "8000:8000"
    volumes:
      - ./backend:/app # For development: live reload
    depends_on:
      db:
        condition: service_healthy
    environment:
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB}
      # Add other backend specific env vars
    env_file:
      - .env

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: cpq_frontend_app
    restart: unless-stopped
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app # For development: live reload
      - /app/node_modules # Anonymous volume to prevent host node_modules overwriting container's
      - /app/.next       # Anonymous volume for Next.js build cache
    depends_on:
      - backend
    environment:
      - NEXT_PUBLIC_API_BASE_URL=http://localhost:8000/api # Or http://backend:8000 if calling server-side
    env_file:
      - .env


volumes:
  postgres_data:
  nocodb_data:



# E2E tests 
1. add materials 
2. add complex product with multiple variations and materials
3. create a quote with multiple products and selcted variations 
4. calculate the quote and verify the calculated values
# 5. verify the final price and breakdown of costs
# 6. verify the bill of materials in the calculated quote
# 7. check what happens with products requirering partial quantities (e.g., 1.5 fence panels) if rounds them up at project level or not
# 8. verify the handling of different unit types and conversions
i want you to create a new e2e test that check what happens if i have a fence that uses rails that come in 5 foot units i know that evry unit (foot) of product will be 0.2, lets test a senario where i need 6 foot and see he charged for two units (cause alwase rounding up)
see #file:e2e_tests 
ok lets define some rule in this system 
1. when a veriation group is deleted all the options go as well 
2. product and variation group is a many to many relationship 
3. when quote is deleted all calculations and entries will go with it 
4. evry test will have its test name in objects it creates
5. evry test before running will use wipe_test_data wich will wipe all data it creates using the api 
6. if not possible to delete make it possible in api 
your alouwed to edit all files in #file:e2e_tests and #file:api.py and #file:models.py 

when ever you want to run the e2e tests just run docker-compose up e2e_tests  
Development Loop :
currently focusing entirely on backend and e2e tests
check current status, Execute plan write tests run fix and loop until succsess verfied 
inorder to mange state of development use state.txt file (create if needed) where you will write evry desition and action you took while developing the project
when i say e2e tests i mean we run docker compose with extra e2e_tests service wich runs tests performing api calls to verify the functionality of the backend 

in tests create unit types only if not existed 

Next Steps:
- run e2e tests, check logs, iterate until evything is good 
use docker-compose down -v & docker-compose up --build -d, then check e2e test results 



1. nocodb setup creates swagger.json in ./../generated_client, then it runs openapi call to make it cpq_client (also in ./../generate_client), also it saves api_token.txt with api_token
2. js_e2e_tests installs the cpq_client and runs it using the api key 
3. js_e2e_tests checks basic crud for diffrent object 
4. it then creates full qalculated quote tests that creates material, products, variation and quote and uses the python api to request calculation and verifies it 
5. commit clean version with 




decisions:
go full developing 
api crud all models 
seprate to files in /api directory 
e2e in js with client generated with generativ ai (basied on api)
e2e: js client (cpq_client.product.all)
e2e_test (crud( unit types, materials, products, all models ))
test postmaster_horizonatl_100_ft 
test pip_100_ft



stage 1:
- We have models created and synced into nocodb 

stage 2:
- api and client for full crud for all models
- tests for real world scenarios like postmaster_horizontal_100_ft and pip_100_ft using api for creating the resource models and generating the quote and calculations


stage 3:
- ui uses client to show a catalog with entries and evrything.




up next:
 compare the postmaster test summery to the excel calcolator (need to see it calculates same amount and bom material amounts)