


# models.py
from datetime import datetime, timezone
from enum import Enum # Add timezone import
from pydantic import field_serializer, BaseModel as PydanticBaseModel, ConfigDict
from sqlalchemy.types import TypeDecorator
from sqlalchemy.dialects.postgresql import JSONB
import json
from typing import List, Optional, Any, Type # Added Any
from decimal import Decimal
from sqlmodel import DDL, Computed, Field, SQLModel, Relationship
from sqlalchemy import Column, Enum as SAEnum, Float, ForeignKey, Integer, String, Boolean, Text, func, UniqueConstraint, event # Add func, UniqueConstraint, SAEnum and event imports

#todo: check about using sql model enum type and sa_enum if exists and matters


# Custom SQLAlchemy TypeDecorator for lists of Pydantic models
class PydanticListJSONB(TypeDecorator):
    """Handles lists of Pydantic models for JSONB storage.

    Converts a list of Pydantic model instances to a list of dictionaries
    for storage, and vice-versa. SQLAlchemy's JSONB type handles the
    actual serialization/deserialization to/from a JSON string in the database.
    """
    impl = JSONB  # Use PostgreSQL JSONB type for native JSON support
    cache_ok = True # Indicates that this TypeDecorator is cacheable

    def __init__(self, pydantic_type: Type[PydanticBaseModel], *args: Any, **kwargs: Any):
        self.pydantic_type = pydantic_type
        super().__init__(*args, **kwargs)

    def process_bind_param(self, value: Optional[List[PydanticBaseModel]], dialect: Any) -> Optional[List[dict]]:
        """Convert Pydantic models to a list of dicts for JSONB storage."""
        if value is None:
            return None
        if not all(isinstance(item, self.pydantic_type) for item in value):
            raise ValueError(f"All items must be instances of {self.pydantic_type.__name__}")
        # The `mode='json'` ensures that any custom serializers (like for Decimal) are applied.
        return [item.model_dump(mode='json') for item in value]

    def process_result_value(self, value: Optional[Any], dialect: Any) -> Optional[List[PydanticBaseModel]]:
        """Convert a list of dicts (from JSONB) back to Pydantic models."""
        if value is None:
            return None
        
        # SQLAlchemy's JSONB type should already parse the JSON string from the DB into a Python list of dicts.
        # If it's a string, it might be a default value or an issue with the JSONB type handling.
        # For robustness, especially if dealing with defaults that might be strings.
        data_to_parse: List[dict]
        if isinstance(value, str):
            try:
                loaded_value = json.loads(value)
                if not isinstance(loaded_value, list):
                    # Or raise a more specific error, log a warning, etc.
                    # This path suggests the DB string wasn't a JSON list.
                    return [] 
                data_to_parse = loaded_value
            except json.JSONDecodeError:
                # Handle cases where string is not valid JSON
                # Depending on requirements, could raise error, log, or return empty/default.
                # For now, returning empty list if parsing fails.
                return [] 
        elif isinstance(value, list):
            data_to_parse = value
        else:
            # Unexpected type from the database for this column.
            # Log warning or raise error. For now, returning empty list.
            return []

        try:
            return [self.pydantic_type(**item) for item in data_to_parse]
        except Exception as e: # Catch Pydantic validation errors or other issues
            # Log the error, and decide on behavior (raise, return partial, return empty)
            # For now, re-raising to make issues visible during development/testing
            # In production, might prefer to return None or an empty list with logging.
            # print(f"Error processing result value for PydanticListJSONB: {e}") # Consider proper logging
            raise # Or return [] / None based on error handling strategy


# Pydantic models for JSONB fields (not SQLModel table models)
class BillOfMaterialEntry(PydanticBaseModel):
    model_config = ConfigDict(from_attributes=True) # Removed json_encoders

    material_name: str
    quantity: Decimal # Changed from float
    unit_cost: Decimal # Changed from float
    total_cost: Decimal # Changed from float
    # Add unit_name for clarity in BOM
    unit_name: Optional[str] = None
    cull_units: Optional[Decimal] = None # Added cull_units
    leftovers: Optional[Decimal] = None # Added leftovers

    @field_serializer('quantity', 'unit_cost', 'total_cost', 'cull_units', 'leftovers', when_used='json')
    def serialize_decimals_to_str(self, v: Optional[Decimal]):
        if v is None:
            return None
        return str(v)


class AppliedRateInfoEntry(PydanticBaseModel):
    model_config = ConfigDict(from_attributes=True) # Removed json_encoders

    name: str
    type: str # e.g., 'margin', 'fee_on_cogs', 'fee_fixed', 'markup'
    rate_value: Decimal # Changed from float
    applied_amount: Decimal # Changed from float

    @field_serializer('rate_value', 'applied_amount', when_used='json')
    def serialize_decimals_to_str(self, v: Decimal):
        return str(v)


class QuoteType(str, Enum):
    """Defines the type of quote, allowing for different business logic flows."""
    GENERAL = "general"
    FENCE_PROJECT = "fence_project"
    DECK_PROJECT = "deck_project"

class QuoteStatus(str, Enum):
    """Defines the status of a quote."""
    DRAFT = "DRAFT"  # Initial state, not yet finalized
    FINAL = "FINAL"  # Finalized and ready for review
    SENT = "SENT"    # Sent to customer
    

class ProductRole(str, Enum):
    """Defines the role of a product within a quote."""
    DEFAULT = "DEFAULT"  # Default role for products
    MAIN = "MAIN"
    SECONDARY = "SECONDARY"
    ADDITIONAL = "ADDITIONAL"  
# todo: maybe should be moved to frontend and just set as strings in the backend (not sure yet)


# SQLModel Table Models

class UnitTypeBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(max_length=50, unique=True, index=True)
    category: str = Field(max_length=50)

class UnitType(UnitTypeBase, table=True):
    __tablename__ = "unit_type" # Explicitly define table name to match plan

    materials_as_supplier_unit: List["Material"] = Relationship(
        back_populates="supplier_unit_type",
        sa_relationship_kwargs={'foreign_keys': '[Material.supplier_unit_type_id]'}
    )
    materials_as_base_unit: List["Material"] = Relationship(
        back_populates="base_unit_type",
        sa_relationship_kwargs={'foreign_keys': '[Material.base_unit_type_id]'}
    )
    products: List["Product"] = Relationship(back_populates="product_unit_type")


# New ProductCategory Model
class ProductCategoryBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    name: str = Field(max_length=100, unique=True, index=True)
    type: str = Field(default="general", max_length=50) # e.g., 'general', 'material', 'labor'
    image_url: Optional[str] = Field(default=None, max_length=255)

class ProductCategory(ProductCategoryBase, table=True):
    __tablename__ = "product_category"

    product_links: List["ProductProductCategoryLink"] = Relationship(back_populates="category")

# New Link Table for Product and ProductCategory
class ProductProductCategoryLink(SQLModel, table=True):
    __tablename__ = "product_product_category_link"
    product_id: int = Field(default=None, foreign_key="product.id", primary_key=True)
    product_category_id: int = Field(default=None, foreign_key="product_category.id", primary_key=True)

    product: "Product" = Relationship(back_populates="category_links")
    category: "ProductCategory" = Relationship(back_populates="product_links")


class MaterialBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True)
    
    name: str = Field(max_length=255, unique=True, index=True)
    description: Optional[str] = Field(default=None)
    cost_per_supplier_unit: Decimal = Field(max_digits=10, decimal_places=2)
    supplier_unit_type_id: Optional[int] = Field(default=None, foreign_key="unit_type.id")
    quantity_in_supplier_unit: Decimal = Field(default=Decimal("1.0"), max_digits=10, decimal_places=3)
    base_unit_type_id: int = Field(foreign_key="unit_type.id")
    cull_rate: Optional[float] = Field(default=0.0) # Added cull_rate property

class Material(MaterialBase, table=True):
    __tablename__ = "material"

    supplier_unit_type: Optional["UnitType"] = Relationship(
        back_populates="materials_as_supplier_unit",
        sa_relationship_kwargs={'foreign_keys': '[Material.supplier_unit_type_id]'}
    )
    base_unit_type: "UnitType" = Relationship(
        back_populates="materials_as_base_unit",
        sa_relationship_kwargs={'foreign_keys': '[Material.base_unit_type_id]'}
    )
    
    product_materials: List["ProductMaterial"] = Relationship(back_populates="material")
    variation_option_materials: List["VariationOptionMaterial"] = Relationship(back_populates="material")
    cull_rate: Optional[float] = Field(default=0.0) # Added cull_rate property


class ProductBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    name: str = Field(max_length=255, unique=True, index=True)
    description: Optional[str] = Field(default=None)
    product_unit_type_id: int = Field(foreign_key="unit_type.id")
    unit_labor_cost: Decimal = Field(default=Decimal("0.00"), max_digits=10, decimal_places=2)
    image_url: Optional[str] = Field(default=None, max_length=255) # New field for product image

class Product(ProductBase, table=True):
    __tablename__ = "product"
    
    product_unit_type: "UnitType" = Relationship(back_populates="products")
    category_links: List["ProductProductCategoryLink"] = Relationship(back_populates="product")
    product_materials: List["ProductMaterial"] = Relationship(back_populates="product", sa_relationship_kwargs={"cascade": "all, delete-orphan"})
    variation_groups: List["VariationGroup"] = Relationship(back_populates="product", sa_relationship_kwargs={"cascade": "all, delete-orphan"})
    
    quote_product_entries: List["QuoteProductEntry"] = Relationship(back_populates="product", sa_relationship_kwargs={"cascade": "all, delete-orphan"})

class ProductMaterialBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Added id as surrogate PK
    name:  Optional[str] = Field(
        sa_column=Column(
            String, 
            comment="Autogenerated by trigger: 'quantity of material_name'"
        )
    )
    product_id: int = Field(foreign_key="product.id")
    material_id: int = Field(foreign_key="material.id")
    material_amount: Decimal = Field(max_digits=50, decimal_places=25)


class ProductMaterial(ProductMaterialBase, table=True):
    __tablename__ = "product_material"
    # product_id and material_id are part of a unique constraint, not composite PK here
    __table_args__ = (UniqueConstraint("product_id", "material_id", name="uq_product_material_prod_mat"),)

    product: "Product" = Relationship(back_populates="product_materials")
    material: "Material" = Relationship(back_populates="product_materials")


# PostgreSQL script to autogenerate the name field in model
set_product_material_name_trigger = DDL('''
    CREATE OR REPLACE FUNCTION set_product_material_name()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.name := (
            SELECT CONCAT(
                NEW.material_amount::numeric(50, 2), -- Cast for consistent formatting
                ' of ', 
                m.name
            )
            FROM material AS m 
            WHERE m.id = NEW.material_id
        );
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Drop the trigger if it already exists to prevent errors on re-creation
    DROP TRIGGER IF EXISTS trg_set_product_material_name ON product_material;

    -- Create the trigger that executes the function before an insert or update
    CREATE TRIGGER trg_set_product_material_name
    BEFORE INSERT OR UPDATE ON product_material
    FOR EACH ROW
    EXECUTE FUNCTION set_product_material_name();
''')

# Register the trigger when the model is created
event.listen(
    ProductMaterial.__table__,
    'after_create',
    set_product_material_name_trigger
)


class VariationGroupBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    name: str = Field(max_length=100)
    product_id: int = Field(foreign_key="product.id")
    selection_type: str = Field(default="single_choice", max_length=20) # 'single_choice', 'multi_choice'
    is_required: bool = Field(default=False)

class VariationGroup(VariationGroupBase, table=True):
    __tablename__ = "variation_group"
    # id is inherited from VariationGroupBase and used as PK
    __table_args__ = (UniqueConstraint("product_id", "name", name="uq_variation_group_product_name"),)

    product: "Product" = Relationship(back_populates="variation_groups")
    options: List["VariationOption"] = Relationship(back_populates="variation_group", sa_relationship_kwargs={"cascade": "all, delete-orphan"})


class VariationOptionBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    name: str = Field(max_length=100)
    variation_group_id: int = Field(foreign_key="variation_group.id")
    value_description: Optional[str] = Field(default=None)
    additional_price: Decimal = Field(default=Decimal("0.00"), max_digits=10, decimal_places=2)
    price_multiplier: Decimal = Field(default=Decimal("1.000"), max_digits=5, decimal_places=3)
    additional_labor_cost_per_product_unit: Decimal = Field(default=Decimal("0.00"), max_digits=10, decimal_places=2)

class VariationOption(VariationOptionBase, table=True):
    __tablename__ = "variation_option"
    # id is inherited from VariationOptionBase and used as PK
    __table_args__ = (UniqueConstraint("variation_group_id", "name", name="uq_variation_option_group_name"),)

    variation_group: "VariationGroup" = Relationship(back_populates="options")
    variation_option_materials: List["VariationOptionMaterial"] = Relationship(back_populates="variation_option", sa_relationship_kwargs={"cascade": "all, delete-orphan"})
    quote_product_entry_variations: List["QuoteProductEntryVariation"] = Relationship(back_populates="variation_option")


class VariationOptionMaterialBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Added id as surrogate PK
    variation_option_id: int = Field(foreign_key="variation_option.id")
    material_id: int = Field(foreign_key="material.id")
    quantity_of_material_base_units_added: Decimal = Field(max_digits=10, decimal_places=3)

class VariationOptionMaterial(VariationOptionMaterialBase, table=True):
    __tablename__ = "variation_option_material"
    # id is inherited from VariationOptionMaterialBase and used as PK
    __table_args__ = (UniqueConstraint("variation_option_id", "material_id", name="uq_vom_option_material"),)

    variation_option: "VariationOption" = Relationship(back_populates="variation_option_materials")
    material: "Material" = Relationship(back_populates="variation_option_materials")


class QuoteConfigBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    name: str = Field(default="Default Quote Config", max_length=100, unique=True, index=True)
    margin_rate: Decimal = Field(default=Decimal("0.30"), max_digits=5, decimal_places=4)
    tax_rate: Decimal = Field(default=Decimal("0.00"), max_digits=5, decimal_places=4)
    sales_commission_rate: Decimal = Field(default=Decimal("0.00"), max_digits=5, decimal_places=4)
    franchise_fee_rate: Decimal = Field(default=Decimal("0.00"), max_digits=5, decimal_places=4)
    additional_fixed_fees: Decimal = Field(default=Decimal("0.00"), max_digits=10, decimal_places=2)
    round_up_materials: bool = Field(default=True) # New field

class QuoteConfig(QuoteConfigBase, table=True):
    __tablename__ = "quote_config"
    quotes: List["Quote"] = Relationship(back_populates="quote_config")


class QuoteBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) 
    name: Optional[str] = Field(default=None, max_length=255)
    description: Optional[str] = Field(default=None)
    quote_config_id: int = Field(foreign_key="quote_config.id")
    status: str = Field(
            default=QuoteStatus.DRAFT, 
            sa_column=Column(
                SAEnum(QuoteStatus), 
                default=QuoteStatus.DRAFT,
            )
        )
    quote_type: QuoteType = Field(
        default=QuoteType.GENERAL,
        sa_column=Column(
            SAEnum(QuoteType),
            default=QuoteType.GENERAL,
            )
        )
    ui_state: Optional[str] = Field(default=None, max_length=100, index=True) # New field for UI state tracking
    
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), # Replaced datetime.utcnow
        sa_column_kwargs={"server_default": func.now()}
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), # Replaced datetime.utcnow
        sa_column_kwargs={"server_default": func.now(), "onupdate": func.now()}
    )

class Quote(QuoteBase, table=True):
    __tablename__ = "quote"
    quote_config: "QuoteConfig" = Relationship(back_populates="quotes")
    product_entries: List["QuoteProductEntry"] = Relationship(back_populates="quote", sa_relationship_kwargs={"cascade": "all, delete-orphan"})
    calculated_quote: Optional["CalculatedQuote"] = Relationship(
        back_populates="quote",
        sa_relationship_kwargs={"cascade": "all, delete-orphan", "uselist": False} # One-to-one
    )


class QuoteProductEntryBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    quote_id: int = Field(foreign_key="quote.id")
    product_id: int = Field(foreign_key="product.id") # ON DELETE RESTRICT is default if not specified for FK
    quantity_of_product_units: Decimal = Field(max_digits=10, decimal_places=2)
    notes: Optional[str] = Field(default=None)
    role: ProductRole = Field(
        default=ProductRole.DEFAULT, 
        sa_column=Column(
            SAEnum(ProductRole), 
            default=ProductRole.DEFAULT,
        )
    ) 

class QuoteProductEntry(QuoteProductEntryBase, table=True):
    __tablename__ = "quote_product_entry"
    id: Optional[int] = Field(default=None, primary_key=True)

    quote: "Quote" = Relationship(back_populates="product_entries")
    product: "Product" = Relationship(back_populates="quote_product_entries")
    selected_variations: List["QuoteProductEntryVariation"] = Relationship(
        back_populates="quote_product_entry",
        sa_relationship_kwargs={"cascade": "all, delete-orphan"}
    )


class QuoteProductEntryVariationBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Added id as surrogate PK
    quote_product_entry_id: int = Field(foreign_key="quote_product_entry.id")
    variation_option_id: int = Field(foreign_key="variation_option.id") # ON DELETE RESTRICT

class QuoteProductEntryVariation(QuoteProductEntryVariationBase, table=True):
    __tablename__ = "quote_product_entry_variation"
    id: Optional[int] = Field(default=None, primary_key=True) # Surrogate PK
    __table_args__ = (UniqueConstraint("quote_product_entry_id", "variation_option_id", name="uq_qpev_entry_option"),)

    quote_product_entry: "QuoteProductEntry" = Relationship(back_populates="selected_variations")
    variation_option: "VariationOption" = Relationship(back_populates="quote_product_entry_variations")


class CalculatedQuoteBase(SQLModel):
    id: Optional[int] = Field(default=None, primary_key=True) # Moved id to top
    quote_id: int = Field(foreign_key="quote.id", unique=True) # Ensures one-to-one with Quote
    bill_of_materials_json: Optional[List[BillOfMaterialEntry]] = Field(
        default=None, sa_column=Column(PydanticListJSONB(BillOfMaterialEntry)) # Use custom TypeDecorator
    )
    total_material_cost: Decimal = Field(max_digits=12, decimal_places=2)
    total_labor_cost: Decimal = Field(max_digits=12, decimal_places=2)
    cost_of_goods_sold: Decimal = Field(max_digits=12, decimal_places=2)
    applied_rates_info_json: Optional[List[AppliedRateInfoEntry]] = Field(
        default=None, sa_column=Column(PydanticListJSONB(AppliedRateInfoEntry)) # Use custom TypeDecorator
    )
    subtotal_before_tax: Decimal = Field(max_digits=12, decimal_places=2)
    tax_amount: Decimal = Field(max_digits=12, decimal_places=2)
    final_price: Decimal = Field(max_digits=12, decimal_places=2)
    calculated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc), # Replaced datetime.utcnow
        sa_column_kwargs={"server_default": func.now()}
    )

class CalculatedQuote(CalculatedQuoteBase, table=True):
    __tablename__ = "calculated_quote"
    id: Optional[int] = Field(default=None, primary_key=True)
    quote: "Quote" = Relationship(back_populates="calculated_quote")




#quote_process_service.py
import logging
from datetime import datetime, timezone
from decimal import Decimal, Decimal as D
from enum import Enum
from typing import List, Optional, Dict, Any

from fastapi import HTTPException
from pydantic import BaseModel, ConfigDict
from sqlalchemy.orm import selectinload
from sqlmodel import Session, select, func

# Assuming your models are in a structure like 'app.models'
# and the calculator is in 'app.services.quote_calculator'
from app.models import (
    ProductRole,
    Quote,
    QuoteProductEntry,
    Product,
    ProductCategory,
    QuoteType,
    VariationGroup,
    VariationOption,
    QuoteProductEntryVariation,
    CalculatedQuote,
    QuoteConfig,
    ProductProductCategoryLink, # Added ProductProductCategoryLink
)
from app.services.quote_calculator import QuoteCalculator

# Configure logger for this service, mirroring QuoteCalculator's style
logger = logging.getLogger("app.services.quote_process_service")
logger.setLevel(logging.DEBUG)
logger.propagate = True


class QuotePreview(BaseModel):
    """A lightweight summary of a quote for list views."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    name: Optional[str]
    description: Optional[str]
    status: str
    quote_type: QuoteType
    updated_at: datetime

class CategoryPreview(BaseModel):
    """A lightweight summary of a product category."""
    model_config = ConfigDict(from_attributes=True)
    
    name: str
    image_url: Optional[str] = None

class ProductPreview(BaseModel):
    """A lightweight summary of a product for catalog views."""
    model_config = ConfigDict(from_attributes=True)

    id: int
    name: str
    description: Optional[str]
    # Assuming Product model has an image_url field
    image_url: Optional[str] = None

class VariationOptionView(BaseModel):
    """Represents a single, selectable option for a variation."""
    model_config = ConfigDict(from_attributes=True)

    id: int
    name: str
    value_description: Optional[str]
    additional_price: Decimal
    is_selected: bool = False

class VariationGroupView(BaseModel):
    """Represents a group of variation options (e.g., 'Color', 'Style')."""
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    name: str
    selection_type: str
    is_required: bool
    options: List[VariationOptionView]

class MaterializedProductEntry(BaseModel):
    """
    A fully detailed DTO for a product entry in a quote.
    It "materializes" data from multiple tables into one object for the UI.
    """
    model_config = ConfigDict(from_attributes=True)

    id: int
    quote_id: int
    product_id: int
    product_name: str
    role: Optional[ProductRole]
    quantity_of_product_units: Decimal
    notes: Optional[str]
    variation_groups: List[VariationGroupView]


# ===================================================================================
# Quote Process Service
# ===================================================================================

class QuoteProcessService:
    """
    Orchestrates the creation and modification of quotes and their components.
    This service is designed to be called by an API layer.
    """
    def __init__(self, session: Session):
        """
        Initializes the service with a database session.

        Args:
            session: The SQLAlchemy/SQLModel session for database operations.
        """
        self.session = session
        self.calculator = QuoteCalculator()

    def _materialize_product_entry(self, entry: QuoteProductEntry) -> MaterializedProductEntry:
        """
        Private helper to convert a QuoteProductEntry model into a rich DTO.
        
        This fetches all related data (product info, variations, selected options)
        and assembles it into a MaterializedProductEntry.
        """
        product = self.session.get(Product, entry.product_id)
        if not product:
            raise ValueError(f"Product with ID {entry.product_id} not found for entry {entry.id}")

        # Eagerly load variation options to avoid N+1 queries
        statement = select(VariationGroup).where(VariationGroup.product_id == product.id).options(selectinload(VariationGroup.options))
        variation_groups = self.session.exec(statement).all()

        materialized_groups = []
        for group in variation_groups:
            materialized_options = []
            for option in group.options:
                is_selected = any(
                    sel_var.variation_option_id == option.id
                    for sel_var in entry.selected_variations
                )
                materialized_options.append(
                    VariationOptionView(
                        id=option.id,
                        name=option.name,
                        value_description=option.value_description,
                        additional_price=option.additional_price,
                        is_selected=is_selected,
                    )
                )
            materialized_groups.append(
                VariationGroupView(
                    id=group.id,
                    name=group.name,
                    selection_type=group.selection_type,
                    is_required=group.is_required,
                    options=materialized_options,
                )
            )

        return MaterializedProductEntry(
            id=entry.id,
            quote_id=entry.quote_id,
            product_id=entry.product_id,
            product_name=product.name,
            role=entry.role,
            quantity_of_product_units=entry.quantity_of_product_units,
            notes=entry.notes,
            variation_groups=materialized_groups,
        )

    # === Quote Management ===
    
    def get_quotes(self, quote_type: Optional[QuoteType] = None, offset: int = 0, limit: int = 100) -> List[QuotePreview]:
        """Fetches a list of quotes, optionally filtered by type, with pagination."""
        logger.info(f"Fetching quotes with type: {quote_type}, offset: {offset}, limit: {limit}")
        statement = select(Quote).offset(offset).limit(limit)
        if quote_type:
            statement = statement.where(Quote.quote_type == quote_type)
        # Consider adding an order_by, e.g., .order_by(Quote.updated_at.desc())
        statement = statement.order_by(Quote.updated_at.desc()) # Added default sorting
        quotes = self.session.exec(statement).all()
        
        logger.debug(f"Raw quotes from database: {quotes}")
        validated_quotes = [QuotePreview.model_validate(q) for q in quotes]
        logger.debug(f"Validated quotes: {validated_quotes}")
        return validated_quotes

    def create_quote(self, name: str, description: Optional[str], quote_type: QuoteType, config_id: int = 1) -> Quote:
        """Creates a new quote with a specific type."""
        logger.info(f"Creating new quote '{name}' of type '{quote_type.value}'")
        quote_config = self.session.get(QuoteConfig, config_id)
        if not quote_config:
            raise ValueError(f"QuoteConfig with id {config_id} not found.")

        try:
            new_quote = Quote(
                name=name,
                description=description,
                quote_type=quote_type,
                status="draft",
                quote_config_id=config_id,
                quote_config=quote_config,
                created_at=datetime.now(timezone.utc),
                updated_at=datetime.now(timezone.utc),
            )
            self.session.add(new_quote)
            self.session.commit()
            self.session.refresh(new_quote)
            logger.info(f"Successfully created Quote ID: {new_quote.id}")
            return new_quote
        except Exception as e:
            logger.error(f"Error creating quote: {e}", exc_info=True)
            self.session.rollback()
            raise

    def update_quote_ui_state(self, quote_id: int, ui_state: str) -> Quote:
        """Updates the UI state of a specific quote."""
        logger.info(f"Updating UI state for Quote ID: {quote_id} to '{ui_state}'")
        quote = self.session.get(Quote, quote_id)
        if not quote:
            logger.warning(f"Quote ID {quote_id} not found for UI state update.")
            raise HTTPException(status_code=404, detail=f"Quote with id {quote_id} not found")
        
        try:
            quote.ui_state = ui_state
            quote.updated_at = datetime.now(timezone.utc) # Also update timestamp
            self.session.add(quote)
            self.session.commit()
            self.session.refresh(quote)
            logger.info(f"Successfully updated UI state for Quote ID: {quote_id} to '{ui_state}'")
            return quote
        except Exception as e:
            logger.error(f"Error updating UI state for quote {quote_id}: {e}", exc_info=True)
            self.session.rollback()
            raise

    def set_quote_status(self, quote_id: int, status: str) -> Quote:
        """Sets the overall status of a quote (e.g., draft, calculated, finalized)."""
        logger.info(f"Setting status for Quote ID: {quote_id} to '{status}'")
        quote = self.session.get(Quote, quote_id)
        if not quote:
            logger.warning(f"Quote ID {quote_id} not found for status update.")
            raise HTTPException(status_code=404, detail=f"Quote with id {quote_id} not found")

        # Optional: Add validation for allowed status values or transitions if needed
        # Example: allowed_statuses = ["draft", "calculated", "finalized", "archived"]
        # if status not in allowed_statuses:
        #     raise ValueError(f"Invalid status: {status}. Allowed statuses are: {', '.join(allowed_statuses)}")

        try:
            quote.status = status
            quote.updated_at = datetime.now(timezone.utc) # Also update timestamp
            self.session.add(quote)
            self.session.commit()
            self.session.refresh(quote)
            logger.info(f"Successfully set status for Quote ID: {quote_id} to '{status}'")
            return quote
        except Exception as e:
            logger.error(f"Error setting status for quote {quote_id}: {e}", exc_info=True)
            self.session.rollback()
            raise

    # === Product & Category Discovery ===

    def get_categories_previews(self, category_type: Optional[str] = None, offset: int = 0, limit: int = 100) -> List[CategoryPreview]: # Added pagination params
        """Gets product categories, optionally filtered by type, with pagination."""
        logger.info(f"Fetching category previews with type: {category_type}, offset: {offset}, limit: {limit}")
        statement = select(ProductCategory).offset(offset).limit(limit)
        if category_type:
            statement = statement.where(ProductCategory.type == category_type)
        statement = statement.order_by(ProductCategory.name) # Added default sorting by name
        categories = self.session.exec(statement).all()
        return [CategoryPreview.model_validate(c) for c in categories]

    def get_products_previews(self, category_name: str, offset: int = 0, limit: int = 100) -> List[ProductPreview]: # Added pagination params
        """Gets product previews for a given category, with pagination."""
        logger.info(f"Fetching product previews for category: {category_name}, offset: {offset}, limit: {limit}")
        # First, find the category to get its ID
        category = self.session.exec(select(ProductCategory).where(ProductCategory.name == category_name)).first()
        if not category:
            logger.warning(f"Category '{category_name}' not found.")
            return [] # Or raise HTTPException(status_code=404, detail=f"Category '{category_name}' not found")

        # Then, find products linked to this category via ProductProductCategoryLink
        statement = (
            select(Product)
            .join(ProductProductCategoryLink, Product.id == ProductProductCategoryLink.product_id)
            .where(ProductProductCategoryLink.product_category_id == category.id)
            .offset(offset)
            .limit(limit)
            .order_by(Product.name) # Added default sorting by name
        )
        products = self.session.exec(statement).all()
        return [ProductPreview.model_validate(p) for p in products]

    # === Quote Product Entry Management ===

    def add_quote_product_entry(self, quote_id: int, product_id: int, quantity: Decimal, role: ProductRole) -> MaterializedProductEntry:
        """Adds a product to a quote with a specific role."""
        logger.info(f"Attempting to add product {product_id} with role {role.value} to quote {quote_id}")
        
        quote = self.session.get(Quote, quote_id)
        if not quote:
            raise ValueError(f"Quote with id {quote_id} not found.")

        # Business Rule: Enforce only one MAIN product.
        if role == ProductRole.MAIN:
            statement = select(QuoteProductEntry).where(QuoteProductEntry.quote_id == quote_id, QuoteProductEntry.role == ProductRole.MAIN)
            existing_main = self.session.exec(statement).first()
            if existing_main:
                logger.warning(f"Quote {quote_id} already has a MAIN product (Entry ID: {existing_main.id}). Cannot add another.")
                raise ValueError("A main product already exists for this quote. Please remove it before adding a new one.")

        try:
            new_entry = QuoteProductEntry(
                quote_id=quote_id,
                product_id=product_id,
                quantity_of_product_units=quantity,
                role=role
            )
            self.session.add(new_entry)
            self.session.commit()
            self.session.refresh(new_entry)
            logger.info(f"Successfully created QuoteProductEntry ID: {new_entry.id}")
            return self._materialize_product_entry(new_entry)
        except Exception as e:
            logger.error(f"Error adding product entry to quote {quote_id}: {e}", exc_info=True)
            self.session.rollback()
            raise

    def get_quote_product_entries(self, quote_id: int, role: Optional[ProductRole] = None, offset: int = 0, limit: int = 100) -> List[MaterializedProductEntry]:
        """Gets materialized product entries for a quote, optionally filtered by role, with pagination."""
        logger.info(f"Fetching product entries for Quote ID: {quote_id}, Role: {role}, Offset: {offset}, Limit: {limit}")
        statement = (
            select(QuoteProductEntry)
            .where(QuoteProductEntry.quote_id == quote_id)
            .options(selectinload(QuoteProductEntry.selected_variations), 
                     selectinload(QuoteProductEntry.product).selectinload(Product.variation_groups).selectinload(VariationGroup.options) # For materialization
            )
            .offset(offset)
            .limit(limit)
            .order_by(QuoteProductEntry.id) # Added default sorting
        )
        if role:
            statement = statement.where(QuoteProductEntry.role == role)
        
        entries = self.session.exec(statement).all()
        if not entries:
            logger.info(f"No product entries found for Quote ID: {quote_id} with specified criteria.")
            return []
        
        materialized_entries = [self._materialize_product_entry(entry) for entry in entries]
        return materialized_entries
    
    def delete_quote_product_entry(self, quote_id: int, product_entry_id: int) -> None:
        """Removes a product entry from a quote, ensuring it belongs to the quote."""
        logger.info(f"Attempting to delete QuoteProductEntry ID: {product_entry_id} from Quote ID: {quote_id}")
        entry = self.session.get(QuoteProductEntry, product_entry_id)
        
        if not entry:
            logger.warning(f"QuoteProductEntry ID {product_entry_id} not found for deletion.")
            # Raise an HTTPException to inform the client, consistent with other error handling.
            raise HTTPException(status_code=404, detail=f"QuoteProductEntry with id {product_entry_id} not found")

        if entry.quote_id != quote_id:
            logger.warning(f"QuoteProductEntry ID {product_entry_id} (belongs to quote {entry.quote_id}) does not belong to quote {quote_id}. Deletion aborted.")
            raise HTTPException(status_code=400, detail=f"QuoteProductEntry with id {product_entry_id} does not belong to quote {quote_id}")

        try:
            self.session.delete(entry)
            self.session.commit()
            logger.info(f"Successfully deleted QuoteProductEntry ID: {product_entry_id}")
        except Exception as e:
            logger.error(f"Error deleting entry {product_entry_id}: {e}", exc_info=True)
            self.session.rollback()
            raise

    def get_quote_product_entry(self, product_entry_id: int) -> MaterializedProductEntry:
        """Gets a single materialized product entry by its ID."""
        logger.info(f"Fetching materialized product entry for ID: {product_entry_id}")
        
        # Eagerly load selected variations to prevent N+1 queries in the materialization step
        # Also load the product itself for materialization
        statement = select(QuoteProductEntry).where(QuoteProductEntry.id == product_entry_id).options(
            selectinload(QuoteProductEntry.selected_variations),
            selectinload(QuoteProductEntry.product).selectinload(Product.variation_groups).selectinload(VariationGroup.options) # For materialization
        )
        entry = self.session.exec(statement).first()
        
        if not entry:
            logger.warning(f"QuoteProductEntry ID {product_entry_id} not found.")
            raise HTTPException(status_code=404, detail=f"QuoteProductEntry with id {product_entry_id} not found")
        
        return self._materialize_product_entry(entry)

    # === Variation Management ===

    def set_quote_product_variation_option(self, product_entry_id: int, variation_option_id: int) -> MaterializedProductEntry:
        """Sets the selected option for a variation group."""
        logger.info(f"Setting variation option {variation_option_id} for entry {product_entry_id}")
        
        entry = self.session.get(QuoteProductEntry, product_entry_id)
        if not entry:
            raise ValueError(f"QuoteProductEntry with id {product_entry_id} not found.")

        option_to_set = self.session.get(VariationOption, variation_option_id)
        if not option_to_set:
            raise ValueError(f"VariationOption with id {variation_option_id} not found.")

        group = self.session.get(VariationGroup, option_to_set.variation_group_id)
        if not group:
            raise ValueError("Could not find parent variation group for the selected option.")
        
        try:
            # If single choice, remove any other selections in the same group
            if group.selection_type == "single_choice":
                statement = select(QuoteProductEntryVariation).where(
                    QuoteProductEntryVariation.quote_product_entry_id == product_entry_id
                ).join(VariationOption).where(
                    VariationOption.variation_group_id == group.id
                )
                existing_selections_in_group = self.session.exec(statement).all()
                for sel in existing_selections_in_group:
                    self.session.delete(sel)
                
                # After clearing, add the new single choice
                new_selection = QuoteProductEntryVariation(
                    quote_product_entry_id=product_entry_id,
                    variation_option_id=variation_option_id
                )
                self.session.add(new_selection)

            elif group.selection_type == "multi_choice":
                # Check if this specific option is already selected
                statement = select(QuoteProductEntryVariation).where(
                    QuoteProductEntryVariation.quote_product_entry_id == product_entry_id,
                    QuoteProductEntryVariation.variation_option_id == variation_option_id
                )
                existing_specific_selection = self.session.exec(statement).first()

                if existing_specific_selection:
                    # Option is already selected, so deselect it (delete)
                    self.session.delete(existing_specific_selection)
                    logger.info(f"Deselected multi-choice option {variation_option_id} for entry {product_entry_id}")
                else:
                    # Option is not selected, so add it
                    new_selection = QuoteProductEntryVariation(
                        quote_product_entry_id=product_entry_id,
                        variation_option_id=variation_option_id
                    )
                    self.session.add(new_selection)
                    logger.info(f"Selected multi-choice option {variation_option_id} for entry {product_entry_id}")
            
            else: # Should not happen with current data model
                logger.error(f"Unknown selection type: {group.selection_type} for group {group.id}")
                raise ValueError(f"Unsupported variation group selection type: {group.selection_type}")

            self.session.commit()
            self.session.refresh(entry) # Refresh entry to load the new/changed selection state
            logger.info(f"Successfully updated variation for entry {product_entry_id}")
            return self._materialize_product_entry(entry)

        except Exception as e:
            logger.error(f"Error setting variation for entry {product_entry_id}: {e}", exc_info=True)
            self.session.rollback()
            raise

    # === Calculation & Finalization ===

    def calculate_quote(self, quote_id: int) -> CalculatedQuote:
        """Triggers the full quote calculation by delegating to QuoteCalculator."""
        logger.info(f"Delegating calculation for Quote ID: {quote_id} to QuoteCalculator.")
        return self.calculator.calculate_and_save_quote(quote_id, self.session)

    def get_calculated_quote(self, quote_id: int) -> Optional[CalculatedQuote]:
        """Retrieves the results of a previous calculation for a quote."""
        logger.info(f"Fetching calculated results for Quote ID: {quote_id}")
        statement = select(CalculatedQuote).where(CalculatedQuote.quote_id == quote_id)
        return self.session.exec(statement).first()



#quote_process_api.py
from typing import List, Optional
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlmodel import Session

from app.database import get_session
from app.models import Quote, QuoteType, ProductRole, CalculatedQuote
from app.services.quote_process import (
    QuoteProcessService,
    QuotePreview,
    CategoryPreview,
    ProductPreview,
    MaterializedProductEntry,
)

router = APIRouter(prefix="/quote-process", tags=["Quote Process"])

def get_quote_process_service(session: Session = Depends(get_session)) -> QuoteProcessService:
    return QuoteProcessService(session=session)

@router.get("/quotes", response_model=List[QuotePreview])
def list_quotes(
    quote_type: Optional[QuoteType] = Query(None, description="Filter by quote type"),
    offset: int = 0,
    limit: int = Query(default=100, le=500),
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """List all quotes, with optional filtering and pagination."""
    return service.get_quotes(quote_type=quote_type, offset=offset, limit=limit)

@router.post("/quotes", response_model=Quote) # Changed to return full Quote model
def create_quote(
    name: str,
    quote_type: QuoteType,
    description: Optional[str] = None,
    config_id: int = 1, # Assuming a default config_id
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Create a new quote."""
    try:
        return service.create_quote(name=name, description=description, quote_type=quote_type, config_id=config_id)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.put("/quotes/{quote_id}/ui-state", response_model=Quote)
def update_quote_ui_state(
    quote_id: int,
    ui_state: str,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Update the UI state of a quote."""
    try:
        return service.update_quote_ui_state(quote_id=quote_id, ui_state=ui_state)
    except HTTPException as e:
        raise e # Re-raise HTTPException directly
    except ValueError as e: # Catch other potential errors like quote not found from service
        raise HTTPException(status_code=404, detail=str(e))


@router.put("/quotes/{quote_id}/status", response_model=Quote)
def set_quote_status(
    quote_id: int,
    status: str,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Set the status of a quote."""
    try:
        return service.set_quote_status(quote_id=quote_id, status=status)
    except HTTPException as e:
        raise e
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/categories", response_model=List[CategoryPreview])
def list_categories(
    category_type: Optional[str] = Query(None, description="Filter by category type"),
    offset: int = 0,
    limit: int = Query(default=100, le=500),
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """List product categories."""
    return service.get_categories_previews(category_type=category_type, offset=offset, limit=limit)

@router.get("/categories/{category_name}/products", response_model=List[ProductPreview])
def list_products_in_category(
    category_name: str,
    offset: int = 0,
    limit: int = Query(default=100, le=500),
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """List products within a specific category."""
    return service.get_products_previews(category_name=category_name, offset=offset, limit=limit)

@router.post("/quotes/{quote_id}/product-entries", response_model=MaterializedProductEntry)
def add_product_to_quote(
    quote_id: int,
    product_id: int,
    quantity: Decimal,
    role: ProductRole,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Add a product entry to a quote."""
    try:
        return service.add_quote_product_entry(quote_id=quote_id, product_id=product_id, quantity=quantity, role=role)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/quotes/{quote_id}/product-entries", response_model=List[MaterializedProductEntry])
def list_quote_product_entries(
    quote_id: int,
    role: Optional[ProductRole] = Query(None, description="Filter by product role"),
    offset: int = 0,
    limit: int = Query(default=100, le=500),
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """List product entries for a quote."""
    return service.get_quote_product_entries(quote_id=quote_id, role=role, offset=offset, limit=limit)

@router.delete("/quotes/{quote_id}/product-entries/{product_entry_id}", status_code=204)
def remove_product_from_quote(
    quote_id: int,
    product_entry_id: int,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Remove a product entry from a quote."""
    try:
        service.delete_quote_product_entry(quote_id=quote_id, product_entry_id=product_entry_id)
        return None # No content response for 204
    except HTTPException as e:
        raise e # Re-raise HTTPException directly from service (e.g., 404 if not found)
    except ValueError as e: # Catch other potential errors
        raise HTTPException(status_code=400, detail=str(e))


@router.get("/product-entries/{product_entry_id}", response_model=MaterializedProductEntry)
def get_materialized_product_entry(
    product_entry_id: int,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Get a single materialized product entry."""
    try:
        return service.get_quote_product_entry(product_entry_id=product_entry_id)
    except HTTPException as e: # Catch 404 from service
        raise e


@router.put("/product-entries/{product_entry_id}/variations/{variation_option_id}", response_model=MaterializedProductEntry)
def set_product_variation_option(
    product_entry_id: int,
    variation_option_id: int,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Set or toggle a variation option for a product entry."""
    try:
        return service.set_quote_product_variation_option(product_entry_id=product_entry_id, variation_option_id=variation_option_id)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/quotes/{quote_id}/calculate", response_model=CalculatedQuote)
def calculate_quote_totals(
    quote_id: int,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Calculate the totals for a quote."""
    try:
        return service.calculate_quote(quote_id=quote_id)
    except ValueError as e: # Or any specific exception your calculator might raise for invalid state
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e: # Catch-all for unexpected errors during calculation
        # Log the exception e
        raise HTTPException(status_code=500, detail="An error occurred during quote calculation.")


@router.get("/quotes/{quote_id}/calculate", response_model=Optional[CalculatedQuote])
def get_calculated_quote_details(
    quote_id: int,
    service: QuoteProcessService = Depends(get_quote_process_service),
):
    """Get the calculated details of a quote if available."""
    calculated_quote = service.get_calculated_quote(quote_id=quote_id)
    if not calculated_quote:
        # You might return 404 if no calculation exists, or an empty object/specific response
        # For now, returning None which FastAPI handles with the Optional response model
        return None
    return calculated_quote



# frontend_mockup.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fence Project CPQ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        /* Simple transition for smoother UI changes */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-slate-100">

    <div id="app" class="h-screen w-screen overflow-hidden">
        <!-- App content will be rendered here by JavaScript -->
    </div>

    <script type="module">
        // ===================================================================================
        // MOCK DATABASE & API SERVICE
        // This section simulates the backend data and service layer we designed.
        // ===================================================================================

        const db = {
            // Hardcoded quote previews (list view)
            quotes: [
                { id: 1, name: "Johnson Residence Fence", description: "Backyard privacy fence project.", status: "calculated", quote_type: "fence_project", updated_at: "2025-06-10T14:48:00.000Z" },
                { id: 2, name: "Miller Commercial Property", description: "Perimeter security fence.", status: "draft", quote_type: "fence_project", updated_at: "2025-06-09T11:20:00.000Z" },
                { id: 3, name: "Davis Garden Gate", description: "Small gate installation.", status: "draft", quote_type: "fence_project", updated_at: "2025-06-08T09:00:00.000Z" },
                { id: 4, name: "Smith Pool Enclosure", description: "Safety fence around the pool.", status: "finalized", quote_type: "fence_project", updated_at: "2025-05-20T17:15:00.000Z" },
                { id: 5, name: "Wilson Ranch Fencing", description: "Large scale agricultural fencing.", status: "draft", quote_type: "fence_project", updated_at: "2025-06-11T10:05:00.000Z" },
            ],
            // Hardcoded product categories
            categories: [
                { name: "Wood Fence", image_url: "https://placehold.co/400x300/a1887f/ffffff?text=Wood", type: "fence" },
                { name: "Vinyl Fence", image_url: "https://placehold.co/400x300/f5f5f5/333333?text=Vinyl", type: "fence" },
                { name: "Chain Link Fence", image_url: "https://placehold.co/400x300/9e9e9e/ffffff?text=Chain+Link", type: "fence" },
                { name: "Gates", image_url: "https://placehold.co/400x300/795548/ffffff?text=Gates", type: "gate" },
                { name: "Project Add-ons", image_url: "https://placehold.co/400x300/455a64/ffffff?text=Add-ons", type: "additional" },
            ],
            // Hardcoded products
            products: [
                // Wood Fences
                { id: 101, category_name: "Wood Fence", name: "6ft Dog Ear Privacy Fence", description: "Classic and affordable wood privacy fence.", image_url: "https://placehold.co/400x300/c8bbaE/ffffff?text=Dog+Ear" },
                { id: 102, category_name: "Wood Fence", name: "6ft Board on Board Fence", description: "Provides maximum privacy with overlapping boards.", image_url: "https://placehold.co/400x300/a1887f/ffffff?text=Board+on+Board" },
                // Vinyl Fences
                { id: 201, category_name: "Vinyl Fence", name: "6ft White Vinyl Privacy", description: "Durable, low-maintenance privacy solution.", image_url: "https://placehold.co/400x300/e0e0e0/333333?text=White+Vinyl" },
                { id: 202, category_name: "Vinyl Fence", name: "4ft Picket Vinyl Fence", description: "Charming and traditional picket style.", image_url: "https://placehold.co/400x300/fafafa/333333?text=Picket+Vinyl" },
                 // Chain Link Fences
                { id: 301, category_name: "Chain Link Fence", name: "6ft Galvanized Chain Link", description: "Secure and durable for residential or commercial use.", image_url: "https://placehold.co/400x300/bdbdbd/ffffff?text=Galvanized" },
                // Gates
                { id: 401, category_name: "Gates", name: "4ft Wide Walk Gate", description: "Standard pedestrian gate, matches fence style.", image_url: "https://placehold.co/400x300/8d6e63/ffffff?text=Walk+Gate" },
                { id: 402, category_name: "Gates", name: "12ft Wide Drive Gate", description: "Double gate for vehicle access.", image_url: "https://placehold.co/400x300/6d4c41/ffffff?text=Drive+Gate" },
                // Add-ons
                { id: 501, category_name: "Project Add-ons", name: "Old Fence Teardown", description: "Removal and disposal of an existing fence (per foot).", image_url: "https://placehold.co/400x300/f44336/ffffff?text=Teardown" },
                { id: 502, category_name: "Project Add-ons", name: "Hard Digging", description: "Additional labor for rocky or difficult soil (per foot).", image_url: "https://placehold.co/400x300/757575/ffffff?text=Hard+Dig" },
            ],
            // Product entry details including variations
            product_details: {
                101: { variation_groups: [ { id: 1001, name: "Length (ft)", selection_type: "single_choice", is_required: true, options: [] }, { id: 1002, name: "Wood Stain", selection_type: "single_choice", is_required: false, options: [ { id: 1, name: "None", value_description: "Natural wood", additional_price: 0, is_selected: true }, { id: 2, name: "Cedar", value_description: "Rich red tones", additional_price: 2.50, is_selected: false }, { id: 3, name: "Redwood", value_description: "Deep brown tones", additional_price: 2.75, is_selected: false } ] } ] },
                102: { variation_groups: [ { id: 1001, name: "Length (ft)", selection_type: "single_choice", is_required: true, options: [] }, { id: 1003, name: "Post Caps", selection_type: "single_choice", is_required: false, options: [ { id: 4, name: "Flat Top", value_description: "Simple and modern", additional_price: 0, is_selected: true }, { id: 5, name: "Pyramid", value_description: "Decorative pointed cap", additional_price: 1.50, is_selected: false } ] } ] },
                201: { variation_groups: [ { id: 1001, name: "Length (ft)", selection_type: "single_choice", is_required: true, options: [] }, { id: 1004, name: "Color", selection_type: "single_choice", is_required: false, options: [ { id: 6, name: "White", value_description: "Classic white", additional_price: 0, is_selected: true }, { id: 7, name: "Tan", value_description: "Earthy tan color", additional_price: 1.00, is_selected: false }, { id: 8, name: "Gray", value_description: "Modern gray", additional_price: 1.25, is_selected: false } ] } ] },
                202: { variation_groups: [ { id: 1001, name: "Length (ft)", selection_type: "single_choice", is_required: true, options: [] } ] },
                301: { variation_groups: [ { id: 1001, name: "Length (ft)", selection_type: "single_choice", is_required: true, options: [] }, { id: 1005, name: "Privacy Slats", selection_type: "single_choice", is_required: false, options: [ { id: 9, name: "None", value_description: "Standard visibility", additional_price: 0, is_selected: true }, { id: 10, name: "Green", value_description: "Adds privacy", additional_price: 3.00, is_selected: false }, { id: 11, name: "Black", value_description: "Adds privacy", additional_price: 3.00, is_selected: false } ] } ] },
                401: { variation_groups: [ { id: 1006, name: "Hardware", selection_type: "single_choice", is_required: true, options: [ { id: 12, name: "Standard Latch", value_description: "Basic gravity latch", additional_price: 0, is_selected: true }, { id: 13, name: "Keyed Lock", value_description: "Secure locking latch", additional_price: 45.00, is_selected: false } ] } ] },
                402: { variation_groups: [ { id: 1007, name: "Automation", selection_type: "single_choice", is_required: false, options: [ { id: 14, name: "Manual", value_description: "Opens by hand", additional_price: 0, is_selected: true }, { id: 15, name: "Automatic Opener", value_description: "Includes motor and remote", additional_price: 1200.00, is_selected: false } ] } ] },
                501: { variation_groups: [ { id: 1008, name: "Length to Remove (ft)", selection_type: "single_choice", is_required: true, options: [] } ] },
                502: { variation_groups: [ { id: 1009, name: "Length of Hard Dig (ft)", selection_type: "single_choice", is_required: true, options: [] } ] },
            },
            // Active quote data will be copied here for modification
            active_quotes: {}
        };

        const api = {
            getQuotes: () => db.quotes,
            getQuote: (id) => {
                if (!db.active_quotes[id]) {
                    const quote_base = db.quotes.find(q => q.id === id);
                    db.active_quotes[id] = { ...quote_base, product_entries: [] };
                }
                return db.active_quotes[id];
            },
            createQuote: (name) => {
                const newId = Math.max(...db.quotes.map(q => q.id)) + 1;
                const newQuote = {
                    id: newId,
                    name: name,
                    description: "Newly created project.",
                    status: "draft",
                    quote_type: "fence_project",
                    updated_at: new Date().toISOString(),
                    product_entries: []
                };
                db.quotes.push(newQuote);
                db.active_quotes[newId] = newQuote;
                return newQuote;
            },
            getCategories: (type) => db.categories.filter(c => c.type === type),
            getProducts: (category_name) => db.products.filter(p => p.category_name === category_name),
            
            getMaterializedProductEntry: (entry) => {
                if (!entry) return null;
                const product = db.products.find(p => p.id === entry.product_id);
                let details = JSON.parse(JSON.stringify(db.product_details[entry.product_id] || { variation_groups: [] }));

                // Sync selections
                details.variation_groups.forEach(group => {
                    const selectedOption = entry.selected_variations.find(sv => sv.group_id === group.id);
                    group.options.forEach(opt => {
                        opt.is_selected = selectedOption ? opt.id === selectedOption.option_id : false;
                    });
                });
                
                return {
                    id: entry.id,
                    quote_id: entry.quote_id,
                    product_id: entry.product_id,
                    product_name: product.name,
                    role: entry.role,
                    quantity_of_product_units: entry.quantity,
                    notes: entry.notes,
                    variation_groups: details.variation_groups
                };
            },

            addQuoteProductEntry: (quoteId, productId, role) => {
                const quote = api.getQuote(quoteId);
                const product = db.products.find(p => p.id === productId);
                if (!quote || !product) return null;

                // Simple business rule: remove existing entry with same role if not 'additional'
                if (role === 'main' || role === 'secondary') {
                    const existingIndex = quote.product_entries.findIndex(e => e.role === role);
                    if (existingIndex > -1) {
                        quote.product_entries.splice(existingIndex, 1);
                    }
                }

                const newEntry = {
                    id: Date.now(), // Use timestamp for unique ID in mock
                    quote_id: quoteId,
                    product_id: productId,
                    role: role,
                    quantity: 1, // Default quantity
                    notes: "",
                    selected_variations: [],
                };
                quote.product_entries.push(newEntry);
                return newEntry;
            },
            deleteQuoteProductEntry: (quoteId, entryId) => {
                const quote = api.getQuote(quoteId);
                if (!quote) return;
                quote.product_entries = quote.product_entries.filter(e => e.id !== entryId);
            },
            updateQuoteProductEntry: (quoteId, entryId, { quantity, notes }) => {
                const quote = api.getQuote(quoteId);
                const entry = quote.product_entries.find(e => e.id === entryId);
                if (entry) {
                    if (quantity !== undefined) entry.quantity = quantity;
                    if (notes !== undefined) entry.notes = notes;
                }
            },
            setQuoteProductVariationOption: (quoteId, entryId, groupId, optionId) => {
                const quote = api.getQuote(quoteId);
                const entry = quote.product_entries.find(e => e.id === entryId);
                if (!entry) return;

                let groupSelection = entry.selected_variations.find(sv => sv.group_id === groupId);
                if (groupSelection) {
                    groupSelection.option_id = optionId;
                } else {
                    entry.selected_variations.push({ group_id: groupId, option_id: optionId });
                }
            }
        };

        // ===================================================================================
        // APPLICATION STATE & RENDERER
        // This section manages the UI state and re-renders the DOM when state changes.
        // ===================================================================================

        const appState = {
            currentView: 'quote_list', // 'quote_list' or 'catalog'
            activeQuoteId: null,
            activeStep: 'choose_category', // The key of the current stepper step
            // Context for the catalog flow
            catalogContext: {
                selectedCategoryName: null,
                activeProductEntryId: null, // ID of entry being configured
            }
        };

        const appRoot = document.getElementById('app');

        /** Main render function that orchestrates the entire UI update */
        function render() {
            // Store scroll position to restore after render
            const scrollY = window.scrollY;

            switch (appState.currentView) {
                case 'quote_list':
                    appRoot.innerHTML = renderQuoteList();
                    break;
                case 'catalog':
                    appRoot.innerHTML = renderCatalogView();
                    break;
                default:
                    appRoot.innerHTML = `<div class="p-8 text-red-500">Error: Unknown view state.</div>`;
            }
            // Restore scroll position
            window.scrollTo(0, scrollY);
        }

        // --- View Renderers ---

        function renderQuoteList() {
            const quotes = api.getQuotes();
            return `
                <div class="min-h-screen bg-slate-100 p-4 sm:p-6 lg:p-8 fade-in">
                    <div class="max-w-7xl mx-auto">
                        <div class="flex justify-between items-center mb-6">
                            <h1 class="text-3xl font-bold text-slate-800">Fence Projects</h1>
                            <button data-action="create-quote" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-colors flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>
                                New Project
                            </button>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            ${quotes.map(renderQuoteCard).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderQuoteCard(quote) {
            const statusStyles = {
                draft: "bg-yellow-100 text-yellow-800",
                calculated: "bg-blue-100 text-blue-800",
                finalized: "bg-green-100 text-green-800",
            };
            return `
                <div data-action="select-quote" data-quote-id="${quote.id}" class="bg-white rounded-xl shadow-lg hover:shadow-2xl hover:-translate-y-1 transition-all duration-300 cursor-pointer overflow-hidden">
                    <div class="p-6">
                        <div class="flex justify-between items-start">
                             <h2 class="text-xl font-bold text-slate-900 mb-2">${quote.name}</h2>
                             <span class="text-xs font-semibold px-2 py-1 rounded-full ${statusStyles[quote.status] || ''}">${quote.status}</span>
                        </div>
                        <p class="text-slate-600 mb-4 h-12">${quote.description}</p>
                        <div class="text-xs text-slate-400">Last updated: ${new Date(quote.updated_at).toLocaleDateString()}</div>
                    </div>
                </div>
            `;
        }

        function renderCatalogView() {
            const quote = api.getQuote(appState.activeQuoteId);
            if (!quote) return `<div class="p-8 text-red-500">Error: Quote not found.</div>`;

            return `
                <div class="flex h-screen bg-white">
                    <!-- Sidebar -->
                    <aside class="w-80 bg-slate-50 border-r border-slate-200 flex flex-col h-full">
                        ${renderSidebar(quote)}
                    </aside>

                    <!-- Main Content -->
                    <main class="flex-1 flex flex-col overflow-hidden">
                        <header class="p-4 border-b border-slate-200 bg-white z-10">
                            <button data-action="back-to-list" class="text-sm text-slate-600 hover:text-blue-600 flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                                Back to All Projects
                            </button>
                        </header>
                        
                        <!-- Stepper -->
                        <div class="p-6 border-b border-slate-200">
                             ${renderStepper()}
                        </div>

                        <!-- Step Content -->
                        <div class="flex-1 overflow-y-auto p-6 bg-slate-100 fade-in">
                            ${renderStepContent(quote)}
                        </div>
                    </main>
                </div>
            `;
        }

        function renderSidebar(quote) {
            const mainProduct = quote.product_entries.find(e => e.role === 'main');
            const secondaryProduct = quote.product_entries.find(e => e.role === 'secondary');
            const additionalProducts = quote.product_entries.filter(e => e.role === 'additional');
            
            const getProductName = (entry) => db.products.find(p => p.id === entry.product_id)?.name || 'Unknown Product';
            
            return `
                 <div class="p-6 border-b border-slate-200">
                    <h2 class="text-lg font-bold text-slate-800">${quote.name}</h2>
                    <p class="text-sm text-slate-500">${quote.description}</p>
                 </div>
                 <div class="flex-1 p-6 overflow-y-auto">
                    <h3 class="font-semibold text-slate-700 mb-4">Project Items</h3>
                    <ul class="space-y-4 text-sm">
                        ${mainProduct ? `
                            <li>
                                <span class="font-semibold text-slate-600 block">Main Product</span>
                                <span class="text-slate-500">${getProductName(mainProduct)}</span>
                            </li>
                        ` : `
                            <li>
                                <span class="font-semibold text-slate-400 block">Main Product</span>
                                <span class="text-slate-400 italic">Not selected</span>
                            </li>
                        `}
                        ${secondaryProduct ? `
                             <li>
                                <span class="font-semibold text-slate-600 block">Secondary Product</span>
                                <span class="text-slate-500">${getProductName(secondaryProduct)}</span>
                            </li>
                        ` : `
                             <li>
                                <span class="font-semibold text-slate-400 block">Secondary Product</span>
                                <span class="text-slate-400 italic">Not selected</span>
                            </li>
                        `}
                        ${additionalProducts.length > 0 ? `
                             <li>
                                <span class="font-semibold text-slate-600 block">Additional Items</span>
                                <ul class="list-disc list-inside mt-1 text-slate-500">
                                    ${additionalProducts.map(p => `<li>${getProductName(p)}</li>`).join('')}
                                </ul>
                            </li>
                        `: ''}
                    </ul>
                 </div>
                 <div class="p-6 border-t border-slate-200">
                     <button data-action="go-to-step" data-step="review" class="w-full bg-green-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-green-700 transition-colors flex items-center justify-center gap-2">
                        Review & Calculate
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
                    </button>
                 </div>
            `;
        }

        function renderStepper() {
            const steps = [
                { key: 'choose_category', label: 'Category' },
                { key: 'choose_main_product', label: 'Main Product' },
                { key: 'configure_main', label: 'Configure Main' },
                { key: 'choose_secondary_product', label: 'Secondary Product' },
                { key: 'configure_secondary', label: 'Configure Secondary' },
                { key: 'select_additional', label: 'Add-ons' },
                { key: 'review', label: 'Review' },
            ];

            const currentIndex = steps.findIndex(s => s.key === appState.activeStep);

            return `
                <nav>
                    <ol class="flex items-center space-x-4 text-sm font-medium text-slate-500">
                        ${steps.map((step, index) => {
                            const isCompleted = index < currentIndex;
                            const isCurrent = index === currentIndex;
                            
                            let classes = 'cursor-pointer';
                            let icon;

                            if (isCurrent) {
                                classes += ' text-blue-600 font-bold';
                                icon = `<span class="flex h-6 w-6 items-center justify-center rounded-full bg-blue-600 text-white mr-2 text-xs">${index + 1}</span>`;
                            } else if (isCompleted) {
                                classes += ' text-green-600 hover:text-green-800';
                                icon = `<span class="flex h-6 w-6 items-center justify-center rounded-full bg-green-500 mr-2">
                                            <svg class="h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                                        </span>`;
                            } else {
                                classes += ' text-slate-400';
                                icon = `<span class="flex h-6 w-6 items-center justify-center rounded-full border border-slate-300 bg-white text-slate-400 mr-2 text-xs">${index + 1}</span>`;
                            }

                            return `
                                <li class="flex items-center ${index > 0 ? 'pl-4' : ''} relative">
                                    ${index > 0 ? `<div class="absolute -left-2 top-1/2 h-0.5 w-6 bg-slate-200"></div>` : ''}
                                    <button data-action="go-to-step" data-step="${step.key}" class="flex items-center ${classes}">
                                        ${icon}
                                        ${step.label}
                                    </button>
                                </li>`;
                        }).join('')}
                    </ol>
                </nav>
            `;
        }

        function renderStepContent(quote) {
            switch (appState.activeStep) {
                case 'choose_category':
                    return renderCategorySelector();
                case 'choose_main_product':
                case 'choose_secondary_product':
                    return renderProductSelector(quote);
                case 'configure_main':
                case 'configure_secondary':
                     return renderProductEntryConfigurator(quote);
                case 'select_additional':
                    return renderAdditionalProductSelector(quote);
                case 'review':
                    return renderReviewView(quote);
                default:
                    return `<div class="text-slate-500">Select a step to begin.</div>`;
            }
        }
        
        function renderCategorySelector() {
            const categories = api.getCategories('fence');
            return `
                <div>
                    <h2 class="text-2xl font-bold text-slate-800 mb-1">Choose a Fence Category</h2>
                    <p class="text-slate-600 mb-6">Select the primary type of fence for this project.</p>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                        ${categories.map(cat => `
                            <div data-action="select-category" data-category-name="${cat.name}" class="bg-white rounded-xl shadow-md hover:shadow-xl hover:border-blue-500 border-2 border-transparent transition-all cursor-pointer overflow-hidden">
                                <img src="${cat.image_url}" alt="${cat.name}" class="w-full h-48 object-cover">
                                <div class="p-4">
                                    <h3 class="font-bold text-lg text-slate-800">${cat.name}</h3>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        function renderProductSelector(quote) {
            const isMain = appState.activeStep === 'choose_main_product';
            const categoryName = isMain ? appState.catalogContext.selectedCategoryName : 'Gates';
            
            if (!categoryName) {
                return `
                    <div class="text-center p-8 bg-white rounded-lg shadow">
                         <h3 class="font-bold text-lg text-slate-700">Please select a category first.</h3>
                         <button data-action="go-to-step" data-step="choose_category" class="mt-4 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition-colors">
                            Go to Category Selection
                         </button>
                    </div>`;
            }
            
            const products = api.getProducts(categoryName);
            const role = isMain ? 'main' : 'secondary';
            const currentEntry = quote.product_entries.find(e => e.role === role);

            return `
                 <div>
                    <h2 class="text-2xl font-bold text-slate-800 mb-1">Choose a ${isMain ? 'Main Fence' : 'Gate'}</h2>
                    <p class="text-slate-600 mb-6">Showing products from the "${categoryName}" category.</p>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                         ${products.map(p => {
                            const isSelected = currentEntry?.product_id === p.id;
                            return `
                                <div data-action="select-product" data-product-id="${p.id}" data-role="${role}" class="bg-white rounded-xl shadow-md hover:shadow-xl ${isSelected ? 'border-blue-500' : 'border-transparent'} border-2 transition-all cursor-pointer overflow-hidden">
                                    <img src="${p.image_url}" alt="${p.name}" class="w-full h-48 object-cover">
                                    <div class="p-4">
                                        <h3 class="font-bold text-lg text-slate-800">${p.name}</h3>
                                        <p class="text-sm text-slate-500 h-10">${p.description}</p>
                                    </div>
                                </div>
                            `;
                         }).join('')}
                    </div>
                </div>
            `;
        }

        function renderProductEntryConfigurator(quote) {
            const entry = quote.product_entries.find(e => e.id === appState.catalogContext.activeProductEntryId);
            if (!entry) {
                 return `<div class="text-center p-8 bg-white rounded-lg shadow">
                         <h3 class="font-bold text-lg text-slate-700">No product selected for configuration.</h3>
                         <p class="text-sm text-slate-500">Please select a product first.</p>
                    </div>`;
            }

            const materializedEntry = api.getMaterializedProductEntry(entry);
            const isMain = entry.role === 'main';

            return `
                <div>
                    <h2 class="text-2xl font-bold text-slate-800 mb-1">Configure: ${materializedEntry.product_name}</h2>
                    <p class="text-slate-600 mb-6">Set the quantity and options for this item.</p>

                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                             <div>
                                <label for="quantity-${entry.id}" class="block text-sm font-medium text-slate-700 mb-1">Quantity ${entry.role === 'main' ? '(ft)' : '(items)'}</label>
                                <input type="number" id="quantity-${entry.id}" data-action="update-quantity" data-entry-id="${entry.id}" value="${materializedEntry.quantity_of_product_units}" class="w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                            </div>

                            ${materializedEntry.variation_groups.map(group => `
                                <div>
                                    <h4 class="text-sm font-medium text-slate-700 mb-2">${group.name} ${group.is_required ? '<span class="text-red-500">*</span>' : ''}</h4>
                                    <div class="flex flex-wrap gap-2">
                                        ${group.options.map(opt => `
                                            <button data-action="select-variation" data-entry-id="${entry.id}" data-group-id="${group.id}" data-option-id="${opt.id}" class="px-4 py-2 text-sm font-medium rounded-md border transition-colors ${opt.is_selected ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-slate-700 border-slate-300 hover:bg-slate-50'}">
                                                ${opt.name}
                                            </button>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>

                         <div class="mt-8 border-t pt-6 flex justify-end">
                            <button data-action="go-to-step" data-step="${isMain ? 'choose_secondary_product' : 'select_additional'}" class="bg-blue-600 text-white font-semibold py-2 px-5 rounded-lg shadow-md hover:bg-blue-700 transition-colors">Next Step</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderAdditionalProductSelector(quote) {
            const products = api.getProducts('Project Add-ons');
            return `
                <div>
                    <h2 class="text-2xl font-bold text-slate-800 mb-1">Select Additional Services</h2>
                    <p class="text-slate-600 mb-6">Choose any extra services needed for this project.</p>
                    <div class="space-y-4">
                        ${products.map(p => {
                             const entry = quote.product_entries.find(e => e.product_id === p.id);
                             const isSelected = !!entry;
                             return `
                                <div class="bg-white p-4 rounded-lg shadow-md flex items-center justify-between">
                                    <div>
                                        <h3 class="font-bold text-slate-800">${p.name}</h3>
                                        <p class="text-sm text-slate-500">${p.description}</p>
                                    </div>
                                    <div class="flex items-center gap-4">
                                        ${isSelected ? `
                                            <input type="number" data-action="update-quantity" data-entry-id="${entry.id}" value="${entry.quantity}" class="w-24 p-2 border border-slate-300 rounded-md shadow-sm text-sm">
                                            <button data-action="toggle-additional" data-product-id="${p.id}" class="text-red-500 hover:text-red-700">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                                            </button>
                                        ` : `
                                            <button data-action="toggle-additional" data-product-id="${p.id}" class="bg-green-100 text-green-700 font-semibold py-2 px-4 rounded-lg hover:bg-green-200 transition-colors">Add</button>
                                        `}
                                    </div>
                                </div>`;
                         }).join('')}
                    </div>
                     <div class="mt-8 border-t pt-6 flex justify-end">
                        <button data-action="go-to-step" data-step="review" class="bg-blue-600 text-white font-semibold py-2 px-5 rounded-lg shadow-md hover:bg-blue-700 transition-colors">Next: Review Quote</button>
                    </div>
                </div>
            `;
        }

        function renderReviewView(quote) {
            const material_cost = quote.product_entries.length * 750.25;
            const labor_cost = quote.product_entries.length * 350.00;
            const subtotal = material_cost + labor_cost;
            const tax = subtotal * 0.08;
            const final_price = subtotal + tax;

            return `
                 <div>
                    <h2 class="text-2xl font-bold text-slate-800 mb-1">Quote Review</h2>
                    <p class="text-slate-600 mb-6">Here is a summary of the estimated project costs. This is for demonstration purposes.</p>
                    <div class="bg-white p-8 rounded-lg shadow-md max-w-2xl mx-auto">
                        <h3 class="text-xl font-bold text-slate-800 mb-6 text-center">${quote.name} - Estimate</h3>
                        <div class="space-y-4">
                            ${quote.product_entries.map(e => {
                                const p = db.products.find(prod => prod.id === e.product_id);
                                return `<div class="flex justify-between items-center text-slate-700"><span>${e.quantity} x ${p.name}</span><span>...</span></div>`;
                            }).join('')}
                        </div>
                        <hr class="my-6">
                        <div class="space-y-3">
                            <div class="flex justify-between text-slate-600"><span>Total Material Cost</span><span>$${material_cost.toFixed(2)}</span></div>
                            <div class="flex justify-between text-slate-600"><span>Total Labor Cost</span><span>$${labor_cost.toFixed(2)}</span></div>
                            <div class="flex justify-between font-semibold text-slate-800"><span>Subtotal</span><span>$${subtotal.toFixed(2)}</span></div>
                            <div class="flex justify-between text-slate-600"><span>Tax (8%)</span><span>$${tax.toFixed(2)}</span></div>
                        </div>
                        <hr class="my-6">
                        <div class="flex justify-between font-bold text-2xl text-slate-900">
                            <span>Final Price</span>
                            <span>$${final_price.toFixed(2)}</span>
                        </div>
                        <div class="mt-8 text-center">
                           <button class="bg-green-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:bg-green-700 transition-colors">Finalize Project</button>
                        </div>
                    </div>
                 </div>
            `;
        }


        // --- Event Handlers & Initializer ---

        function handleAppClick(e) {
            const target = e.target.closest('[data-action]');
            if (!target) return;

            const { action, quoteId, categoryName, productId, role, step, entryId, groupId, optionId } = target.dataset;

            switch (action) {
                case 'create-quote': {
                    const name = prompt("Enter a name for the new project:", "New Fence Project");
                    if (name) {
                        const newQuote = api.createQuote(name);
                        appState.activeQuoteId = newQuote.id;
                        appState.currentView = 'catalog';
                        appState.activeStep = 'choose_category';
                    }
                    break;
                }
                case 'select-quote':
                    appState.activeQuoteId = parseInt(quoteId);
                    appState.currentView = 'catalog';
                    appState.activeStep = 'choose_category';
                    break;
                case 'back-to-list':
                    appState.currentView = 'quote_list';
                    appState.activeQuoteId = null;
                    break;
                case 'select-category':
                    appState.catalogContext.selectedCategoryName = categoryName;
                    appState.activeStep = 'choose_main_product';
                    break;
                case 'go-to-step':
                    appState.activeStep = step;
                    break;
                case 'select-product': {
                    const newEntry = api.addQuoteProductEntry(appState.activeQuoteId, parseInt(productId), role);
                    appState.catalogContext.activeProductEntryId = newEntry.id;
                    appState.activeStep = role === 'main' ? 'configure_main' : 'configure_secondary';
                    break;
                }
                 case 'toggle-additional': {
                    const quote = api.getQuote(appState.activeQuoteId);
                    const existing = quote.product_entries.find(e => e.product_id === parseInt(productId));
                    if(existing) {
                        api.deleteQuoteProductEntry(appState.activeQuoteId, existing.id);
                    } else {
                        api.addQuoteProductEntry(appState.activeQuoteId, parseInt(productId), 'additional');
                    }
                    break;
                }
                case 'select-variation':
                    api.setQuoteProductVariationOption(appState.activeQuoteId, parseInt(entryId), parseInt(groupId), parseInt(optionId));
                    break;
            }
            render();
        }

        function handleAppInput(e){
            const target = e.target.closest('[data-action]');
            if (!target || target.dataset.action !== 'update-quantity') return;
            const { entryId } = target.dataset;
            
            // Debounce or handle on blur for performance, but for mock, immediate update is fine
            const quantity = parseFloat(e.target.value) || 0;
            api.updateQuoteProductEntry(appState.activeQuoteId, parseInt(entryId), { quantity });

            // Re-render sidebar to show changes if needed (not implemented for simplicity)
        }

        function init() {
            appRoot.addEventListener('click', handleAppClick);
            appRoot.addEventListener('input', handleAppInput); // For quantity changes
            render();
        }

        init();

    </script>
</body>
</html>





frontend plan 


"Fence Catalog" webapp plan:



next js web application 
cd into the project directory and create a new Next.js app via the command line.

project:
    config.tsx // env loads  / base url and other config 
    quote_process_models.tsx
    quote_process_mock_client.tsx
    quote_process_client.tsx 
    apiClient // return const apiClient: IQuoteProcessAPI = USE_MOCK_API ? quoteProcessMockApi : quoteProcessClient;
    fence_catalog_service.tsx (main service for the app, handles business logic of fence catalog, using the quote process layer)
    <other next.js app files>


web app implmentation refrences
we have the mockup for our webapp in frontend_mockup.html it has implmented complete desinge for our app with mock data
quote_process - fence catalog coupling:
// The quote process is a service that allos us to create a quote via api add some products and get a calculated quote, 
// the fence catalog service will use it to get avilable categories, products and mange the guidenc of user thrue the process of filling a fence quote with requires declared products (for instance main product (fence), secondary products (gates), additional products (hardigging, taredown, etc).
// the fence catalog will hold the busiess logic related to this our quoting use case and will use quote_type, quote_ui_state, and product category types for showing relevant products. (see models.py)
your job is to extract the data and desinge from the mockup and implement it in the next.js app using the best practices for production next.js apps
create production ready next.js app that will work with our api.

# quote-process api base url: https://api.wb-const.bina-solutions.co.il/api/v1/quote-process


deploy latest api version and ask google ai studio to build the app with link to our deployment api

